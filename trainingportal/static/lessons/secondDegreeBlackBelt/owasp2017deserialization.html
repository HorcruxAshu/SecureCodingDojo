
<h4>About the vulnerabilities</h4>
<p>
  The combination of using unpatched 3rd party components and the unsafe use of deserialization can be fatal. 
  The scariest part is that 3rd party components don't even need to be directly used. 
  They only need to be on the class path of the vulnerable application and the class loader will attempt to deserialize them if a vulnerable type is sent.
  </p>
  
  <ul>
  <li>Vulnerable and Outdated Components
      <blockquote>
      <i>You are likely vulnerable:
        <br><br>
        *If you do not know the versions of all components you use (both client-side and server-side). This includes components you directly use as well as nested dependencies.
        <br><br>
        *If the software is vulnerable, unsupported, or out of date. This includes the OS, web/application server, database management system (DBMS), applications, APIs and all components, runtime environments, and libraries.
        <br><br>
        *If you do not scan for vulnerabilities regularly and subscribe to security bulletins related to the components you use.
    </i>    
      <footer>From OWASP Top 10 2021<a target="_blank" rel="noopener noreferrer" href="https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/">A06 - Vulnerable and Outdated Components</a></footer>
      </blockquote>
  </li>
  </ul>
  
  
<ul>
<li>Insecure Deserialization
    <blockquote class="blockquote m-4">
    <i>The impact of deserialization flaws cannot be overstated. These flaws can lead to remote code execution attacks, one of the most serious attacks possible.</i>
    <footer class="blockquote-footer">From OWASP Top 10 2017<a target="_blank" rel="noopener noreferrer" href="https://www.owasp.org/index.php/Top_10-2017_A8-Insecure_Deserialization">A8-Insecure Deserialization</a></footer>
</blockquote>
</li>
</ul>
<p>
    <strong>Note: </strong> Starting with OWASP Top 10 2021, Insecure Deserialization is classified as a form of Software and Data Integrity Flaw.
</p>
<br></br>

<h4>Exploiting Deserialization</h4>
<p>
The Open Source project <a href="https://github.com/frohoff/ysoserial">ysoserial</a> provides an open source tool to test and exploit Insecure Deserialization flaws in Java apps.
</p>
<br></br>


<h5>Challenge Tips and Tricks</h5>
<p>
Once you are logged in you will notice that the application accepts serialized command objects. You can use ysoserial to generate a
base64 encoded object and you can use curl to send the object to the application. 
<pre class="pre-scrollable">
curl -H 'Cookie:JSESSIONID=_YOUR_SESSION_ID_' '_COMMAND_PROC_URL_SUBMIT_COMMAND' -H 'Content-Type: multipart/form-data; boundary=----123' --data-binary '------123\r\nContent-Disposition: form-data; name=\"object\"\r\n\r\nrO0ABXNyAApzZXJpYWwuQ2F0mJizcryhARMCAAFMAARuYW1ldAASTGphdmEvbGFuZy9TdHJpbmc7eHB0AApTZXJpYWwgQ2F0\r\n------123--\r\n' -L
</pre>
<br>
Replace the base64 object in the curl command with the object generated by ysoserial using the command of your choice.
<br><br>
You should have the code for the <code>commandproc</code> Java application from a previous challenge so you can generate your own Command objects to create a STOP command. 
You'll also notice that you don't absolutely need the code, the app can serialize an object for you however it will only accept commands that have the correct authentication code. 
The authentication code is stored in a binary so you can't exfiltrate it with XXE unless you convert it to base64.
<br><br>
Java prevents command chaining so you must use only one command. OpenSSL is ideal for this (also because you don't want to leave the converted command code for other challengers)
<br><br>
Use the command <code>openssl enc -aes-256-ecb -in _AUTH_CODE_FILE_ -out /tmp/_YOUR_FILE_NAME.enc -base64 -k _YOUR_SECRET_</code>
<br><br>
Then you can use the XXE login request (save that in a Burp repeater Tab or Postman tab) to list the contents of <code>file://tmp/</code> and download your encrypted file.
Be careful to remove the \n inserted by API Gateway in the response to the pinger request.
<br><br>
The command  <code>openssl enc -aes-256-ecb -in /_YOUR_FILE_NAME.enc -base64 -k _YOUR_SECRET_ -d -md md5|base64</code> will decrypt the authentication code to a base64 string.
</p>